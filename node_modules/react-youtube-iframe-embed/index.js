import React, {Component, createContext} from 'react';
import FlexEmbed from 'flex-embed';
import PropTypes from 'prop-types';

const noop = () => {};

const defaultValue = {isReady: false};
const {Provider, Consumer} = createContext(defaultValue);

export class YouTubeIframeAPIProvider extends Component {
  static propTypes = {
    children: PropTypes.any.isRequired
  };

  state = defaultValue;

  componentDidMount() {
    const tag = document.createElement('script');
    tag.id = 'ytapi';
    tag.src = 'https://www.youtube.com/player_api';

    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    window.onYouTubeIframeAPIReady = () => this.setState({isReady: true});
  }

  render() {
    const {children} = this.props;

    return <Provider value={this.state}>{children}</Provider>;
  }
}

/**
 * Embed YouTube video
 */
export default class YouTubeEmbed extends Component {
  static propTypes = {
    /**
     * Whether to play the single video or the entire playlist again and again
     */
    loop: PropTypes.bool,
    /**
     * Play video muted
     */
    mute: PropTypes.bool,
    /**
     * Embedded video player's width in PX, e.g. `640`
     */
    width: PropTypes.number,
    /**
     * Embedded video player's height in PX, e.g. `390`
     */
    height: PropTypes.number,
    /**
     * Embedded video's ID, e.g. `IjTBcqpl2kc`
     */
    videoId: PropTypes.string.isRequired,
    /**
     * Play video automatically
     */
    autoPlay: PropTypes.bool,
    /**
     * Whether the video player controls are displayed
     */
    controls: PropTypes.bool,
    /**
     * Whether to play the video in portrait mode
     */
    portrait: PropTypes.bool,
    /**
     * Player element's class names
     */
    className: PropTypes.string,
    /**
     * Play video inline instead of full screen on mobile devices
     */
    playsInline: PropTypes.bool,
    /**
     * Function to run when video is cued and ready to play
     */
    onCued: PropTypes.func,
    /**
     * Function to run when video ended
     */
    onEnded: PropTypes.func,
    /**
     * Function to run when player has finished loading and is ready to begin
     * receiving API calls
     */
    onReady: PropTypes.func,
    /**
     * Function to run when video start to play for the first time
     */
    onStart: PropTypes.func,
    /**
     * Function to run when video paused
     */
    onPaused: PropTypes.func,
    /**
     * Function to run whenever video's state changed to playing
     */
    onPlaying: PropTypes.func,
    /**
     * Function to run for every one second when video are playing
     */
    onProgress: PropTypes.func,
    /**
     * Function to run when video's state changed to buffering
     */
    onBuffering: PropTypes.func,
    /**
     * Function to run when the player first loads a video
     */
    onUnstarted: PropTypes.func
  };

  static defaultProps = {
    loop: false,
    mute: false,
    autoPlay: false,
    controls: true,
    portrait: false,
    playsInline: true,

    onCued: noop,
    onEnded: noop,
    onReady: noop,
    onPaused: noop,
    onPlaying: noop,
    onBuffering: noop,
    onUnstarted: noop
  };

  componentWillUnmount() {
    if (this.player) {
      this.player.destroy();
    }
  }

  componentWillReceiveProps({videoId}) {
    if (videoId !== this.props.videoId) {
      this.player.cueVideoById(videoId);
    }
  }

  onReady = (...args) => {
    const {mute, onReady, autoPlay} = this.props;

    if (mute) {
      this.player.mute();
    }

    if (autoPlay) {
      const event = args[0];

      event.target.playVideo();
    }

    if (onReady) {
      onReady(...args);
    }
  };

  onStateChange = ({data}) => {
    const {onStart, onProgress} = this.props;

    switch (data) {
      case 1:
        if (onProgress && !this.progress) {
          this.progress = setInterval(() => {
            onProgress(this.player.getCurrentTime());
          }, 1000);
        }

        if (onStart && !this.isStarted) {
          onStart();

          this.isStarted = true;
        }

        return this.props.onPlaying();

      case -1:
      case 0:
      case 5:
        /* reset started state */
        this.isStarted = false;

      // eslint-disable-line no-fallthrough
      default:
        if (onProgress && this.progress) {
          this.progress = clearInterval(this.progress);
        }

        switch (data) {
          case -1:
            return this.props.onUnstarted();
          case 0:
            return this.props.onEnded();
          case 2:
            return this.props.onPaused();
          case 3:
            return this.props.onBuffering();
          case 5:
            return this.props.onCued();
        }
    }
  };

  createPlayer = ref => {
    const {
      mute,
      width,
      height,
      videoId,
      autoPlay,
      controls,
      playsInline
    } = this.props;

    this.player = new window.YT.Player(ref, {
      width: width ? width.toString() : undefined,
      height: height ? height.toString() : undefined,
      events: {
        onReady: this.onReady,
        onStateChange: this.onStateChange
      },
      videoId,
      playerVars: {
        mute: mute ? 1 : 0,
        autoplay: autoPlay ? 1 : 0,
        controls: controls ? 1 : 0,
        playsinline: playsInline ? '1' : '0'
      }
    });
  };

  setRef = ref => {
    if (this.player) {
      this.player.destroy();
    }

    this.createPlayer(ref);
  };

  render() {
    const {width, height, portrait, className} = this.props;

    return (
      <FlexEmbed ratio={portrait ? 16 / 9 : 9 / 16}>
        <Consumer>
          {({isReady}) => (
            <div
              ref={isReady ? this.setRef : undefined}
              style={{width: width || '100%', height: height || '100%'}}
              className={className}
            />
          )}
        </Consumer>
      </FlexEmbed>
    );
  }
}
